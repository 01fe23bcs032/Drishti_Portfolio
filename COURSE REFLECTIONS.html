<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chitranagari: Smart City Design</title>
    <style>
        body {
            font-family: 'Georgia', sans-serif;
            background-color: #bbc1cc;
            color: #333;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        h1, h2, h3 {
            text-align: center;
            color: #c177b2;
        }

        .container {
            max-width: 1200px;
            margin: auto;
            padding: 20px;
        }
       .navigation-boxes {
    display: flex;
    justify-content: center;
    gap: 20px;
    flex-wrap: wrap;
    margin: 30px 5px;
}

.nav-box {
    background: #c177b2; /* Muted pink, matching the heading color */
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.5);
    text-align: center;
    transition: transform 0.3s ease, background 0.3s ease, color 0.3s ease;
    max-width: 200px;
}

.nav-box a {
    color: #ffffff; /* White text for contrast */
    text-decoration: none;
    font-size: 1.0em;
    font-weight: bold;
}

.nav-box i {
    font-size: 1.8em;
    color: #ffffff; /* White icons for contrast */
    margin-bottom: 10px;
    display: block;
}

.nav-box:hover {
    transform: translateY(-5px);
    background: #bbc1cc; /* Light background color matching the page background */
    color: #333; /* Darker text for contrast on hover */
}

.nav-box:hover a {
    color: #333; /* Darker text for contrast on hover */
}

.nav-box:hover i {
    color: #333; /* Darker icon color for hover */
}

        section {
            margin-bottom: 40px;
            padding: 20px;
            background: #ffffff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        section:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
        }

        h2 {
            font-size: 26px;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        ul {
            list-style: none;
            padding-left: 20px;
        }

        li {
            position: relative;
            padding-left: 20px;
            margin-bottom: 10px;
        }

        li:before {
            content: "\2022";
            position: absolute;
            left: 0;
            color: #C09BBC;
        }

        code {
            background-color: #e8f5e9;
            color: #C09BBC;
            padding: 2px 4px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
        }

        .highlight {
            color: #e91e63;
            font-weight: bold;
        }

        a {
            color: #1e88e5;
            text-decoration: none;
            transition: color 0.3s;
        }

        a:hover {
            color: #1565c0;
        }

        .icon {
            font-size: 34px;
            margin-right: 5px;
        }

        .title-icon {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CHITRANAGARI: Smart City Design</h1>
        <div class="navigation-boxes">
        <div class="nav-box"><i class="fas fa-chart-home"></i><a href="index.html">Home</a></div>
        <div class="nav-box"><i class="fas fa-chart-line"></i><a href="BUISNESS CASES.html">Business Cases</a></div>
        <div class="nav-box"><i class="fas fa-chart-bar"></i><a href="About Project.html">Project Synopsis</a></div>
        <div class="nav-box"><i class="fas fa-lightbulb"></i><a href="COURSE REFLECTIONS.html">Course Reflections</a></div>
        <div class="nav-box"><i class="fas fa-bullseye"></i><a href="RELATED SDG MAPPING.html">SDG Mapping</a></div>
        <div class="nav-box"><i class="fas fa-tools"></i><a href="implementation.html">Project Implementation</a></div>
    </div>

        <section>
            <h2 class="title-icon"><span class="icon">üë®‚Äçüë©‚Äçüëß‚Äçüë¶</span> Population Density and Data</h2>
            <p>Chitranagari, inspired by Jaipur, showcases a vibrant mix of residents and visitors, creating a dynamic geographic and economic profile.</p>
            <p>Strategic urban planning is essential to manage its growing population effectively.</p>
        </section>

        <section>
            <h2 class="title-icon"><span class="icon">üå¶</span> Water Supply and Management</h2>
            <p>Located in Rajasthan, Chitranagari faces challenges due to extreme weather affecting water availability. Proper water resource management is critical to sustain the growing population and vibrant tourism sector.</p>
        </section>

        <section>
            <h2 class="title-icon"><span class="icon">üö¶</span> Traffic Data and Management</h2>
            <p>Chitranagari's desert environment impacts road quality. Systematic traffic management is crucial to ensure smooth transportation and reduce congestion.</p>
        </section>

        <section>
            <h2>Course Learning Reflections</h2>

            <h3>1. Iteration, Recursion, and Backtracking</h3>
            <ul>
                <li><span class="highlight">Iteration:</span> Repeatedly performing a task, e.g., spiral arrangements in flowers.Iteration is a fundamental programming technique where a sequence of instructions is executed repeatedly until a specified condition is met. This approach is commonly implemented using loops, such as for, while, or do-while constructs in programming languages. </li>
                    Iteration is ideal for tasks involving:
 <li>Traversing arrays or lists. </li>
 <li>Repeating a fixed number of operations. </li>
 <li>Performing incremental calculations like summation or finding the maximum/minimum.</li>
                <li><span class="highlight">Backtracking:</span>  Exploring possibilities and reverting when necessary,Backtracking is an algorithmic paradigm that builds solutions incrementally, abandoning paths that fail to satisfy the constraints of the problem. It is particularly useful in scenarios where we explore all potential solutions but prune paths that are unlikely to lead to success.We used the backtracking in the N-Queen's Problem. Areal life sitaution would include e.g. as Sudoko.</li>
                <li><span class="highlight">Recursion:</span> Breaking a problem into smaller sub-problems. It is a process where a function calls itself to solve smaller instances of the same problem. This technique is particularly suited for problems with a divide-and-conquer nature, where the solution to a larger problem depends on solutions to its subproblems. e.g., Cell divion.</li>
            </ul>

            <h3>2. Space and Time Efficiency</h3>
            <ul>
               <li><span class="highlight">Space Efficiency:</span> Space efficiency measures the amount of memory(RAM) an algorithm requires relative to its input size(n).The key factors affecting Space Efficiency are input size and In-place and Non in-place algorithms.</li>
<li>Ways to Measure Space Efficiency:
Space Complexity: The total memory used by an algorithm as a function of the input size.</li>

                <li><span class="highlight">Time Efficiency:</span>Time efficiency measures the amount of time an algorithm takes to complete as a function of the size of its input (n).The key factors affecting Time Efficiency are input size and Number of Operations. </li>
                <li>Ways to measure Time Efficiency:Big-O Notation,Big-Theta,Big-Omega</li>
              <li><strong>Orders of Growth</strong>: It determines how the time increases as we increase the inputs.</li>
                <li>It can be Constant, Logarithmic, Linear, Quadratic, Cubic.</li>
            </ul>

            <h3>3. Design Principles</h3>
            <p>Using the right principle simplifies problems:</p>
            <ul>
                <li><span class="highlight">Pruning:</span> Pruning refers to the process of cutting off certain branches in a search space or decision tree to avoid unnecessary computations. <li>This is commonly applied in optimization problems or tree traversal algorithms, where not all possibilities need to be explored.</li>
 <li>Ideal for N-Queens problem.</li>

                 <li><span class="highlight">Bit Manipulation:</span>Bit manipulation involves using bitwise operators to perform low-level operations directly on the binary representations of integers.</li>
 <li>This technique is efficient and often used to solve problems related to optimization.</li>
              <li> Used in Fenwick Trees.</li>

            </ul>

            <h3>4. Tree Data Structures</h3>
            <p>Tree structures are designed for hierarchical data organization, where elements (nodes) are connected by edges. A tree starts from a root node and branches out into child nodes, with no cycles.</p>
            <ul>
                                <li><span class="highlight">Balanced Trees:</span> (AVL, Red-Black, 2-3 trees) Useful for maintaining balance through rotations, enabling faster search, insertion, and deletion operations with a time complexity of \( O(\log n) \).</li>
<li><strong>Binary Search Tree (BST):</strong> Efficient for searching sorted data but may become unbalanced.</li>
        <li><strong>AVL Tree:</strong> A self-balancing BST for optimal performance.</li>
        <li><strong>2-3 Tree:</strong> Handles dynamic data effectively.</li>
        <li><strong>Red-Black Tree:</strong> A balanced tree with fewer rebalancing operations.</li>                
                <li><span class="highlight">Trie:</span> Ideal for managing character data like dictionaries or prefixes.</li>
                <li><span class="highlight">Heap:</span> Must satisfy the tree shape and parental dominance properties.</li>
            </ul>

            <h3>5. Array Query Algorithms</h3>
            <p>Array query algorithms are effective for small and static datasets, such as finding the sum, minimum, maximum, or other properties over a range of indices. These algorithms leverage <span class="highlight">pre-computation</span> by storing previously calculated results to avoid redundant calculations.</p>
            <ul>
                <li>Structures like Segment Trees, Sparse Tables, and Fenwick Trees use this principle, making them efficient for array queries.</li>
            </ul>

            <h3>6. Difference Between Trees and Graphs</h3>
            <ul>
                <li><span class="highlight">Trees:</span> Hierarchical data structures with n nodes and n-1 edges, where each node has a single root-to-node path, making them acyclic. Traversals include Inorder, Preorder, and Postorder.</li>
                <li><span class="highlight">Graphs:</span> Generalized structures where nodes (vertices) connect through edges, which can form cycles and can be directed or undirected. Applications include navigation systems and other network purposes.. DFS and BFS are also used in  traversals</li>
            </ul>

            <h3>7. Sorting and Searching Algorithms</h3>
            <p>Sorting algorithms organize data for efficient access and manipulation, including:</p>
            <ul>
                <li><span class="highlight">Quick Sort</span>Quick Sort is a divide-and-conquer algorithm that partitions the array into two parts based on a pivot, placing smaller elements to the left and larger elements to the right.It is suitable for large datasets</li>
                <li><span class="highlight">Merge Sort</span>Merge Sort is a divide-and-conquer algorithm that splits the array into halves, sorts each half recursively, and then merges the sorted halves into a single sorted array.It is suitable for large datasets</li>
                <li><span class="highlight">Bubble Sort</span> Bubble Sort repeatedly compares adjacent elements in the list and swaps. It works well for small datasets.</li>
                <li><span class="highlight">Insertion Sort</span>Insertion Sort is a simple sorting algorithm that sorts the final sorted array one element at a time. It picks each element from the unsorted portion and insrts to form a sorted array. </li>

            </ul>
            <p>Searching algorithms locate data within structures, including:</p>
            <ul>
                <li><span class="highlight">Rabin-Karp</span>The Rabin-Karp algorithm is a pattern-searching algorithm that uses hashing to efficiently find occurrences of a pattern string within a text string.</li>
                <li><span class="highlight">Knuth-Morris-Pratt</span>The principle behind the algorithm that is to generate the prefix table P is that:
Find the length of the longest proper prefix in the sub-pattern that matches a proper suffix
in the same sub-pattern.</li>
                <li><span class="highlight">Boyer-Moore</span>This algorithm involves constructing two tables. One is Bad symbol shift table and other
one is good Suffix Shift table.</li>
            </ul>

            <h3>8. Graph Algorithms</h3>
            <p>Graph algorithms solve essential problems in connectivity and optimization:</p>
            <ul>
                <li><span class="highlight">Kruskal:</span> Finds the shortest path by visiting all nodes.</li>
                <li><span class="highlight">Dijkstra:</span> Uses a cost matrix to find the shortest path but need not visit all nodes.</li>
                <li><span class="highlight">Warshall:</span> Shows if there is a path from one node to another.</li>
                <li><span class="highlight">Floyd:</span>The Floyd Algorithm is a dynamic programming method used to find the shortest paths between all pairs of vertices in a weighted graph.</li>
