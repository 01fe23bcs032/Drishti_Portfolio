<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chitranagari: Smart City Design</title>
    <style>
        body {
            font-family: 'Georgia', sans-serif;
            background-color: #f3f4f6;
            color: #333;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        h1, h2, h3 {
            text-align: center;
            color: #C09BBC;
        }

        .container {
            max-width: 1200px;
            margin: auto;
            padding: 20px;
        }

        section {
            margin-bottom: 40px;
            padding: 20px;
            background: #ffffff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        section:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
        }

        h2 {
            font-size: 26px;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        ul {
            list-style: none;
            padding-left: 20px;
        }

        li {
            position: relative;
            padding-left: 20px;
            margin-bottom: 10px;
        }

        li:before {
            content: "\2022";
            position: absolute;
            left: 0;
            color: #C09BBC;
        }

        code {
            background-color: #e8f5e9;
            color: #C09BBC;
            padding: 2px 4px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
        }

        .highlight {
            color: #e91e63;
            font-weight: bold;
        }

        a {
            color: #1e88e5;
            text-decoration: none;
            transition: color 0.3s;
        }

        a:hover {
            color: #1565c0;
        }

        .icon {
            font-size: 24px;
            margin-right: 5px;
        }

        .title-icon {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chitranagari: Smart City Design</h1>

        <section>
            <h2 class="title-icon"><span class="icon">üë®‚Äçüë©‚Äçüëß‚Äçüë¶</span> Population Density and Data</h2>
            <p>Chitranagari, inspired by Jaipur, showcases a vibrant mix of residents and visitors, creating a dynamic geographic and economic profile.</p>
            <p>Strategic urban planning is essential to manage its growing population effectively.</p>
        </section>

        <section>
            <h2 class="title-icon"><span class="icon">üå¶Ô∏è</span> Water Supply and Management</h2>
            <p>Located in Rajasthan, Chitranagari faces challenges due to extreme weather affecting water availability. Proper water resource management is critical to sustain the growing population and vibrant tourism sector.</p>
        </section>

        <section>
            <h2 class="title-icon"><span class="icon">üö¶</span> Traffic Data and Management</h2>
            <p>Chitranagari's desert environment impacts road quality. Systematic traffic management is crucial to ensure smooth transportation and reduce congestion.</p>
        </section>

        <section>
            <h2>Course Learning Reflections</h2>

            <h3>1. Iteration, Recursion, and Backtracking</h3>
            <ul>
                <li><span class="highlight">Iteration:</span> Repeatedly performing a task, e.g., spiral arrangements in flowers.Iteration is a fundamental programming technique where a sequence of instructions is executed repeatedly until a specified condition is met. This approach is commonly implemented using loops, such as for, while, or do-while constructs in programming languages. </li>
                    Iteration is ideal for tasks involving:
 <li>Traversing arrays or lists. </li>
 <li>Repeating a fixed number of operations. </li>
 <li>Performing incremental calculations like summation or finding the maximum/minimum.</li>
                <li><span class="highlight">Backtracking:</span>  Exploring possibilities and reverting when necessary,Backtracking is an algorithmic paradigm that builds solutions incrementally, abandoning paths that fail to satisfy the constraints of the problem. It is particularly useful in scenarios where we explore all potential solutions but prune paths that are unlikely to lead to success.We used the backtracking in the N-Queen's Problem. Areal life sitaution would include e.g. as Sudoko.</li>
                <li><span class="highlight">Recursion:</span> Breaking a problem into smaller sub-problems. It is a process where a function calls itself to solve smaller instances of the same problem. This technique is particularly suited for problems with a divide-and-conquer nature, where the solution to a larger problem depends on solutions to its subproblems. e.g., Cell divion.</li>
            </ul>

            <h3>2. Space and Time Efficiency</h3>
            <ul>
                <li><span class="highlight">Space Efficiency:</span> Memory required by an algorithm during execution.</li>
                <li><span class="highlight">Time Efficiency:</span>Time efficiency measures the amount of time an algorithm takes to complete as a function of the size of its input (n).The key factors affecting Time Efficiency are input size and Number of Operations. </li>
                <li>Ways to measure Time Efficiency:Big-O Notation,Big-Theta,Big-Omega</li>
            </ul>

            <h3>3. Design Principles</h3>
            <p>Using the right principle simplifies problems:</p>
            <ul>
                <li><span class="highlight">Pruning:</span> Ideal for N-Queens problem.</li>
                <li><span class="highlight">Bit Manipulation:</span> Used in Fenwick Trees.</li>
            </ul>

            <h3>4. Tree Data Structures</h3>
            <p>Tree structures are designed for hierarchical data organization, where elements (nodes) are connected by edges. A tree starts from a root node and branches out into child nodes, with no cycles.</p>
            <ul>
                <li><span class="highlight">Balanced Trees:</span> (AVL, Red-Black, 2-3 trees) Useful for maintaining balance through rotations, enabling faster search, insertion, and deletion operations with a time complexity of \( O(\log n) \).</li>
                <li><span class="highlight">Trie:</span> Ideal for managing character data like dictionaries or prefixes.</li>
                <li><span class="highlight">Heap:</span> Must satisfy the tree shape and parental dominance properties.</li>
            </ul>

            <h3>5. Array Query Algorithms</h3>
            <p>Array query algorithms are effective for small and static datasets, such as finding the sum, minimum, maximum, or other properties over a range of indices. These algorithms leverage <span class="highlight">pre-computation</span> by storing previously calculated results to avoid redundant calculations.</p>
            <ul>
                <li>Structures like Segment Trees, Sparse Tables, and Fenwick Trees use this principle, making them efficient for array queries.</li>
            </ul>

            <h3>6. Difference Between Trees and Graphs</h3>
            <ul>
                <li><span class="highlight">Trees:</span> Hierarchical data structures with n nodes and n-1 edges, where each node has a single root-to-node path, making them acyclic. Traversals include Inorder, Preorder, and Postorder. DFS and BFS are also used in tree traversals.</li>
                <li><span class="highlight">Graphs:</span> Generalized structures where nodes (vertices) connect through edges, which can form cycles and can be directed or undirected. Applications include navigation systems and other network purposes.</li>
            </ul>

            <h3>7. Sorting and Searching Algorithms</h3>
            <p>Sorting algorithms organize data for efficient access and manipulation, including:</p>
            <ul>
                <li><span class="highlight">Quick Sort</span></li>
                <li><span class="highlight">Merge Sort</span></li>
                <li><span class="highlight">Bubble Sort</span></li>
                <li><span class="highlight">Insertion Sort</span></li>
            </ul>
            <p>Searching algorithms locate data within structures, including:</p>
            <ul>
                <li><span class="highlight">Rabin-Karp</span></li>
                <li><span class="highlight">Knuth-Morris-Pratt</span></li>
                <li><span class="highlight">Boyer-Moore</span></li>
            </ul>

            <h3>8. Graph Algorithms</h3>
            <p>Graph algorithms solve essential problems in connectivity and optimization:</p>
            <ul>
                <li><span class="highlight">Kruskal:</span> Finds the shortest path by visiting all nodes.</li>
                <li><span class="highlight">Dijkstra:</span> Uses a cost matrix to find the shortest path but need not visit all nodes.</li>
                <li><span class="highlight">Warshall:</span> Shows if there is a path from one node to another.</li>
                <li><span class="highlight">Floyd
